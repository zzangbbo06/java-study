package sec02.exam05;

public class Example {
	
	public static void main(String[] args) {
		ImplementationC impl = new ImplementationC();
		
		InterfaceA iA = impl;
		iA.methodA();
		System.out.println();
		
		InterfaceB iB = impl;
		iB.methodB();
		System.out.println();
		
		InterfaceC iC = impl;
		iC.methodA();
		iC.methodB();
		iC.methodC();
	
	}
	
	
	// 인터페이스 장점
	// 1. 선언과 구현을 분리할 수 있다.
	// 인터페이스는 사용 방법(규약)만 정의하고, 구현은 각 클래스가 담당
	// 결과적으로 코드 변경에 유리하며, 확장성과 유연성이 높아짐
	// 2. 개발 시간을 단축할 수 있다.
	// 구현체가 아직 완성되지 않아도 인터페이스를 기반으로 사용하는 쪽과 개발을 병행할 수 있다.
	// 예: A 클래스가 B 클래스를 사용해야 할 때
	// A --> B (직접 의존): B가 완성되어야 A를 개발 가능
	// A --> 인터페이스 <-- B (간접 의존): 인터페이스만 먼저 정의하면 A와 B를 병렬로 개발 가능
	// 3. 표준화가 가능하다.
	// 여러 개발자나 조직이 동일한 인터페이스를 기반으로 구현을 다르게 할 수 있다.
	// 예: JDBC (DriverManager는 Connection 인터페이스만 사용하고, DB 벤더마다 구현체를 제공)
	// 4. 다형성 구현이 가능하다.
	// 같은 인터페이스를 구현한 객체들을 동일한 타입으로 다룰 수 있어, 유연한 코드 작성 가능
	   
	// 추상 클래스와 인터페이스의 차이(abstract_vs_interface 표 참고)
	   
	// 추상 클래스와 인터페이스 정리
	// 추상 클래스: 공통 기능을 미리 만들어두고, 일부만 자식이 구현
	// 인터페이스: 구현 없이 설계 규격만 정의해서 유연하게 구조 확장
	   
	// 언제 추상 클래스를 사용할까?
	// 공통 기능의 재사용이 필요할 때
	// 여러 하위 클래스에 공통 필드나 메소드 구현을 제공하고 싶을 때
	// 일부 메소드는 구현해두고, 일부만 하위 클래스에서 구현하게 만들고 싶을 때
	// 상태(state)를 유지하는 필드가 필요한 경우
	   
	// 언제 인터페이스를 사용할까?
	// 설계 규약을 정의하고 구현을 나중에 위임할 때
	// 여러 클래스들이 같은 규칙을 따르고 동일한 동작(내부 구현은 다른)을 강제하고 싶을 때
	// 다중 구현이 필요할 때

	//예를 들어:
	//"동물"이라는 추상 클래스를 만들면, "숨쉬기" 같은 공통 동작을 미리 만들어 둘 수 있음
	//"날 수 있는"이라는 인터페이스는, "날다"라는 기능이 있어야 한다는 규칙만 정해줌

}
